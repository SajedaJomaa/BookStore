{"ast":null,"code":"// import React, { useState, useEffect, useRef, useCallback } from 'react';\n// import ShowAvailableBooks from './ShowAvailableBooks.js';\n// import { fetchAvailableBooks } from '../services/api-call.js';\n// export default function BookImage() {\n//     const [booksData, setBooksData] = useState([]);\n//     const [page, setPage] = useState(1);\n//     const [isLoading, setIsLoading] = useState(false);\n//     const observer = useRef(null);\n\n//     useEffect(() => {\n//         const fetchBookData = async (page) => {\n//             setIsLoading(true);\n//             try {\n//                 const resData = await fetchAvailableBooks(page);\n//                 const newBooksData = resData.items.map(item => ({\n//                     id: item.id,\n//                     imageLinks: item.volumeInfo.imageLinks,\n//                     title: item.volumeInfo.title\n//                 }));\n//                 setBooksData(prevData => [...prevData, ...newBooksData]);\n//             } catch (error) {\n//                 console.error('Error fetching book data:', error.message);\n//             } finally {\n//                 setIsLoading(false);\n//             }\n//         };\n\n//         fetchBookData(page);\n//     }, [page]);\n\n//     const lastImageRef = useCallback(node => {\n//         if (isLoading) return;\n//         if (observer.current) observer.current.disconnect();\n\n//         observer.current = new IntersectionObserver(entries => {\n//             if (entries[0].isIntersecting && !isLoading) {\n//                 setPage(prevPage => prevPage + 1);\n//             }\n//         });\n\n//         if (node) observer.current.observe(node);\n//     }, [isLoading]);\n\n//     return (\n//         <div>\n//             <ShowAvailableBooks booksData={booksData} lastImageRef={lastImageRef} isLoading={isLoading} />\n//         </div>\n//     );\n// }","map":{"version":3,"names":[],"sources":["C:/Users/Msys/OneDrive/Desktop/BookStore/frontend/src/components/BookImage.js"],"sourcesContent":["// import React, { useState, useEffect, useRef, useCallback } from 'react';\r\n// import ShowAvailableBooks from './ShowAvailableBooks.js';\r\n// import { fetchAvailableBooks } from '../services/api-call.js';\r\n// export default function BookImage() {\r\n//     const [booksData, setBooksData] = useState([]);\r\n//     const [page, setPage] = useState(1);\r\n//     const [isLoading, setIsLoading] = useState(false);\r\n//     const observer = useRef(null);\r\n\r\n//     useEffect(() => {\r\n//         const fetchBookData = async (page) => {\r\n//             setIsLoading(true);\r\n//             try {\r\n//                 const resData = await fetchAvailableBooks(page);\r\n//                 const newBooksData = resData.items.map(item => ({\r\n//                     id: item.id,\r\n//                     imageLinks: item.volumeInfo.imageLinks,\r\n//                     title: item.volumeInfo.title\r\n//                 }));\r\n//                 setBooksData(prevData => [...prevData, ...newBooksData]);\r\n//             } catch (error) {\r\n//                 console.error('Error fetching book data:', error.message);\r\n//             } finally {\r\n//                 setIsLoading(false);\r\n//             }\r\n//         };\r\n\r\n//         fetchBookData(page);\r\n//     }, [page]);\r\n\r\n//     const lastImageRef = useCallback(node => {\r\n//         if (isLoading) return;\r\n//         if (observer.current) observer.current.disconnect();\r\n\r\n//         observer.current = new IntersectionObserver(entries => {\r\n//             if (entries[0].isIntersecting && !isLoading) {\r\n//                 setPage(prevPage => prevPage + 1);\r\n//             }\r\n//         });\r\n\r\n//         if (node) observer.current.observe(node);\r\n//     }, [isLoading]);\r\n\r\n//     return (\r\n//         <div>\r\n//             <ShowAvailableBooks booksData={booksData} lastImageRef={lastImageRef} isLoading={isLoading} />\r\n//         </div>\r\n//     );\r\n// }\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}